# Aps Project - Sorting Algorithms

## Used Algorithms:

- Quick Sort;
- Bubble Sort;
- Insertion Sort;
- Selection Sort.

### About Project and Development (Portuguese - Brazil):

Após estudo bibliográfico foi implementado e comparado os algoritmos Quick Sort, Bubble Sort, Selection Sort e Insertion Sort. 

#### Interface Gráfica 

Com objetivo de tornar este trabalho mais atrativo, fora utilizado java swing para criação de uma interface gráfica em que as ações do usuário fazem as operações de ordenações necessárias, simplesmente através de cliques nos botões. Trata-se de uma interface bem simples e básica, que contempla um menu com três opções, tais quais: “Algoritmos”, “Arquivos” e “Estatísticas”. Cada opção do menu contém um estilo de página padrão, tendo um cabeçalho, um corpo e um ou mais botões de ações.
Além disso, o principal motivo de ser feito uma interface gráfica é para que todo o trabalho possa ser executado apenas com cliques, de forma que não seja necessário fazer nada manualmente, tal como ocorre em diversos softwares de mercado.
Foram realizados operações de tratamento de erros e exceções em todos os locais necessários, afim de tornar tal interface com uma maior usabilidade e intuitividade, e também para evitar maiores transtornos e problemas que pudessem vir a ocorrer.
Será destrinchado sobre a funcionalidade de cada opção do menu a partir de então, em subtópicos.
 
#### Algoritmos

Na primeira opção do menu, “Algoritmos”, entende-se que é a opção principal, onde são realizados de fatos as operações de ordenações e onde os algoritmos de ordenação, obviamente, serão executados. Na tela, é mostrado os quatro algoritmos os quais foram implementados, e no fim há um botão de executar. Tal botão, quando pressionado, irá buscar no “path” raiz do projeto por arquivos com extensão “txt” cujo nome seja igual aos dos algoritmos, ou seja, irá verificar se na raiz do projeto existem os seguintes arquivos: “QuickSort.txt”, “BubbleSort.txt”, “SelectionSort.txt” e “InsertionSort.txt”, exatamente com esses nomes. Caso não exista pelo menos um, não será executado nenhuma operação, e será exibido para o usuário uma caixa de diálogo de erro, mais especificamente um “JOptionPane” customizado com a seguinte mensagem para notificação do usuário: “Os arquivos referentes aos algoritmos não existem”, ou seja, significa que todos os arquivos devem estar criados, exatamente com esses nomes e dentro da raiz do projeto para que seus conteúdos sejam lidos, de forma que em cada linha desses há um número, e assim será possível realizar sua ordenação. Então, para cada arquivo, será executado o algoritmo correspondente ao seu nome, por exemplo, no arquivo “QuickSort.txt” será operado o algoritmo Quick Sort.
Caso existam todos os arquivos necessários quando for clicado em executar, então o conteúdo de tais arquivos serão lidos e ordenados conforme já citado em relação aos seus nomes. Caso um ou mais arquivo(s) não contenha(m) apenas números, será mostrado um diálogo de erro para o usuário notificando-o sobre o primeiro arquivo encontrado que não conteve apenas números, com a seguinte mensagem, por exemplo no caso do arquivo do Bubble Sort não conter apenas números: “O arquivo BubbleSort.txt não contém apenas números”, e consequentemente nenhum dos arquivos será ordenado, só será realizado a operação de ordenação de fato, se todos os arquivos estão certos, contendo apenas números.
Agora, caso todos os requisitos citados sejam atendidos, então será lido o conteúdo de cada arquivo, realizado a operação correspondente a tal, e sobrescrito seu conteúdo, de forma a armazenar seu mesmo conteúdo novamente, mas agora ordenado de forma crescente.
Consequentemente fica nítido que foram realizados operações de “IO”, ou seja, de entrada e saída de dados. Sabe-se que tais operações de “IO” levam alguns milissegundos ou até segundos para ocorrerem, mas tal tempo não é computado para verificação do tempo levado na execução dos algoritmos, isso porque fora feito para cada algoritmo, uma pequena implementação interna do tempo que é levado na execução daquele algoritmo específico que esteja executando no momento, assim, consequentemente, o tempo computado será apenas o da execução do algoritmo, não tendo qualquer interferência externa.

#### Arquivos

Na segunda opção do menu, “Arquivos”, têm-se o cabeçalho da página que é igual para todos, o corpo dessa página que é só o título dela, “Manipulação dos arquivos” e no fim dois botões, responsáveis por realizar as operações oferecidas neste. Um dos botões tem o texto “Criar os arquivos” e o outro “Alterar o valor dos Arquivos”.
A principal função desta opção é facilitar o uso principal do sistema, que é a execução dos algoritmos. Como citado anteriormente, é preciso que existam os arquivos no “path” raiz exatamente com aqueles nomes, e tais arquivos são criados vazios automaticamente no local certo quando clicado no botão de criar os arquivos. Caso um ou mais arquivos já existisse(m), será(ão) criado(s) apenas o(s) que falta(m). Além disso, é mostrado um diálogo de erro caso um arquivo já existisse no “path”, com a seguinte mensagem, por exemplo no Bubble Sort: “Arquivo BubbleSort.txt já existe!”. Essa mensagem de diálogo de erro é mostrada para cada algoritmo que já tem seu arquivo criado, ou seja, caso os quatro já estejam criados, será mostrado quatro desses diálogos para deixar bem claro para o usuário quais arquivos já estavam criados. Os arquivos já criados não serão substituídos e nem terão seus valores alterados só por clicar nesse botão de criar os arquivos.
Caso todos os quatro arquivos já tivessem sido criados anteriormente, tal como já fora citado seria mostrado apenas os diálogos de erro, mas caso pelo menos um arquivo seja criado, então será mostrado um diálogo de informação com a seguinte mensagem: “Ao menos um arquivo foi gerado com sucesso !”, ou seja, mostrando ao usuário que apenas um arquivo foi gerado com sucesso, de forma que pode ter sido gerado apenas um, dois, três ou todos os quatro arquivos, caso não existissem anteriormente. Inclusive esses modais podem aparecer juntos, pois pode acontecer de já haver um arquivo mas faltar outros e sendo criado apenas um deles, o diálogo de informação será mostrado, portanto pode-se ter o diálogo de erro de algum(ns) arquivo(s) específico(s) que já tinha(m) sido criado(s), mais o de informação. 
Já o segundo botão, tal como seu texto diz, serve para alterar o valor desses arquivos. Caso ao menos um arquivo não seja encontrado, nenhum dos arquivos terá seu conteúdo alterado, e será mostrado um diálogo de erro com o seguinte conteúdo: “Arquivos não encontrados. Por favor, crie-os primeiro”, ou seja, sua função mesmo só será executada também se todos os arquivos tiverem sido criados.
Seguindo o raciocínio, se todas as condições forem atendidas, então, será mostrado uma caixa de diálogo com entradas para o usuário, em que o usuário deve digitar três campos: “Valor mínimo”, o “Valor máximo” e a “Quantidade de números”. Esse diálogo tem dois botões, de “OK” e de “Cancelar”. Caso clique em cancelar ou feche o diálogo, nada ocorrerá. Se for clicado no botão de “OK”, mas o valor de qualquer um dos campos for diferente de um número inteiro, então será mostrado um diálogo de erro com o conteúdo: “Digite apenas números inteiros”. Caso todos os valores sejam números inteiros, então serão gerados n números entre o valor mínimo e o valor máximo que o usuário digitou, sendo n o valor do campo quantidade de números, e tais números serão salvos dentro de cada um dos arquivos, de forma que cada número será colocado em uma linha, e todos os números ficarão em uma ordem aleatória, já que cada um deles foi gerado de forma automática. Portanto, todos os arquivos passarão a ter o mesmo conteúdo, sendo este definido no intervalo e na quantidade que o usuário quis.

#### Estatísticas

Na terceira e última opção do menu, “Estatísticas”, têm-se o cabeçalho da página, o corpo dessa página que é só o título dela, “Exibição das Estatísticas” e no fim um botão com o texto de “Gerar Gráficos”.
Tal como o nome propõe, ao clicar nesse botão será gerado um gráfico. Antes de ser realizado sua função, é feito uma verificação, se desde que o projeto começou a rodar, se foi feito alguma execução dos algoritmos, ou seja, se o usuário clicou pelo menos uma vez no botão de “Executar” do menu de Algoritmos. Caso não tenha clicado, será mostrado um diálogo de erro com o seguinte conteúdo: “É necessário realizar pelo menos uma ordenação para poder gerar gráficos”, pois o tempo levado pela execução de cada algoritmo será armazenado em um array, e caso nenhuma execução tenha ocorrido, o array estará vazio, logo, não fará sentido gerar um gráfico sem conter conteúdo nele.
Agora, se fora executado apenas uma operação de ordenação, então será criado uma nova janela no sistema operacional contendo um gráfico de linhas, sendo cada linha correspondente a cada algoritmo, de forma a cada uma destas ter uma cor própria, e juntamente a uma legenda no gráfico, consegue-se deixar nítido a diferença de tempo levado na execução de cada algoritmo, uma vez que o eixo X representa o tempo levado em milissegundos, aproximadamente, na execução daquele algoritmo específico. O eixo Y é apenas para mostrar o início e o fim do tempo de execução do algoritmo.
Apenas para essa parte dos gráficos, foi-se utilizado a linguagem python, pois tal linguagem possui uma biblioteca chamada “matplotlib” que torna muito fácil a criação e manipulação de gráficos. Resumidamente, no “path” raiz do projeto há um arquivo chamado “algoritmos.py”, que é o arquivo python responsável por fazer essa operação. Ele recebe dois parâmetros que são passados via chamada do arquivo, ou seja, pelos parâmetros argv, sendo o primeiro o tempo levado por cada algoritmo, separando o tempo de cada algoritmo por uma vírgula, e depois o segundo parâmetro os nomes dos algoritmos correspondentes a cada valor, também separados por vírgula e na mesma ordem, pois no python ao receber esses parâmetros do argv, é dado um split de forma a transformá-lo em um array e poder plotar cada gráfico individualmente, já que passa-se a ter um array com tempo levado pelo algoritmo e um com o nome do algoritmo, sendo suas posições correspondentes. Então em java é seguido o seguinte flow para tornar tais execuções possíveis: é aberto um terminal através da classe ProcessBuilder que permite isso, depois é pegado o path da raiz do projeto, e executado no terminal para ir até esse path e por fim é chamado o script python passando o que é necessário para ele. Foi necessário realizar alguns tratamentos e verificação de qual era o sistema operacional para poder executar os comandos no terminal de forma certa, já que há diferenças entre o “cmd” e o “bash”.

#### Arquitetura

Em relação a arquitetação do projeto, fora seguido algumas boas práticas, de forma a atingir uma arquitetura plausível, mas que claramente pode ser melhorada. Basicamente as aplicações em java são separadas por pacotes, então cada pacote fora criado com um intuito. Dentro do pacote main está a classe Main.java, que é o entry point do arquivo, que basicamente antes de executar qualquer coisa, verifica quais são os algoritmos colocados dentro do pacote algorithms, e depois verifica se há os arquivos “txt” referentes a eles para que as validações a partir daí possam a ocorrer de maneira correta. Além disso ele apenas chama a interface gráfica.
A interface gráfica está dentro do pacote ui, cujo objetivo é conter apenas a parte visual, a parte gráfica ao qual o usuário terá contato (“User Interface”). Dentro desse pacote há o Menu.java que é onde está a interface gráfica. Os botões que possuem ações, apenas servem como ponte para chamar métodos ou instanciar objetos de classes que serão responsáveis por fazer as operações necessárias relativas ao botão, mas que estão em outros pacotes.
Todos os algoritmos estão dentro do pacote algorithms, onde há quatro classes dentro, sendo cada uma um algoritmo com sua respectiva ordenação.
Outro pacote é o customPanes, onde foi feito algumas customizações de modais, mais especificamente dos diálogos para poder mostrar ao usuário de forma personalizada as mensagens que eram necessárias. Dentro dele há o Error.java responsável por todos os diálogos de erro, o JOptionPaneMultiInput.java responsável pela janela de alteração de valor dos arquivos, e o Success.java que é o diálogo de informação, representando sucesso.
Por fim há apenas mais dois pacotes: io, que é onde ocorre todas as operações de “IO”, ou seja, tudo que é referente aos arquivos está dentro do arquivo FileIO que por sua vez está dentro deste pacote; e o pacote helpers, que contém métodos que ajudam a realizar as operações necessárias. Dentro de helpers, têm-se o CallPythonFile.java que é responsável por chamar o arquivo python através do ProcessBuilder, como citado anteriormente; o ExecuteAlgorithms que é onde todos os algoritmos de ordenação são chamados para executar suas respectivas operações; o GenerateGraphics que chama o CallPythonFile, cujo objetivo dos dois em conjunto é chamar o arquivo python; e por fim o RandomNumbers.java, que irá gerar os números de forma aleatória com base no intervalo e quantidade proposto pelo usuário na parte de alteração do valor dos arquivos.
Trata-se de uma estrutura que descentraliza as responsabilidades de cada arquivo dentro de um pacote específico correspondente a tal, mas que poderia ser melhorada.

#### Considerações Finais

O assunto de algoritmos de ordenação mostrou-se interessante, em virtude de que não possuía conhecimento algum referente ao tema, que, por sua vez, é um tópico fundamental na computação, em vista de que a grande maioria dos softwares comerciais trabalham justamente com a manipulação de dados, e colocar esses dados em ordem é algo muito recorrente, de forma que é um tema ao qual qualquer desenvolvedor deve ter conhecimento sobre.
Em relação aos testes realizados, estes se mostraram interessantes pois puderam trazer a noção de realidade de forma prática em relação a qualidade e aplicabilidade dos algoritmos, uma vez que têm-se constatado o tempo levado por cada algoritmo em suas devidas execuções. Dessa forma, pode-se perceber que o algoritmo mais rápido dos que foram implementados é o Quick Sort, e isso justifica o motivo deste ser usado na maioria dos casos. Em contrapartida, o Bubble Sort é o menos eficiente, o que levou mais tempo para executar em todos os casos, inclusive a discrepância entre este e o Quick Sort chega a ser absurda, de forma que é nítido que o Bubble Sort apenas serve para fins didáticos e de estudo mesmo, e sua utilização na prática não é nada viável. Entretanto, sua implementação é bem fácil de ser aprendida.
Inclusive, pode-se compreender mais facilmente a partir do que fora citado o motivo do Quick Sort ser considerado um algoritmo de método eficiente, uma vez que ele requer um número menor de comparações, portanto é bem viável sua utilização em quantidades maiores de dados. Enquanto os demais algoritmos que foram implementados, são considerados algoritmos de métodos simples, os quais são adequados para menores quantidade de dados.
O Insertion Sort é um algoritmo bem interessante de ser implementado em casos quando o conjunto de dados já está quase ordenado, assim serão necessários poucos movimentos para finalizar sua ordenação.
Quando se trata de um conjunto pequenos de dados, como já citado anteriormente é até mais recomendável usar algoritmos de método simples devido a questão de consumo de memória e simplicidade de implementação. Em se tratando destes algoritmos, o Selection Sort é um dos mais velozes para ordenar vetores com tamanhos pequenos.
Claramente esta é uma análise bem superficial dos algoritmos, até porque cada algoritmo possui suas dadas particularidades, e para entendermos todos os algoritmos com perfeição no que diz respeito aos melhores casos de uso, seria preciso conhecimentos matemáticos e lógicos mais aprofundados. Porém, com o dado trabalho foi-se adquirido um bom repertório sobre estes de forma que já é possível fazer uso de tais algoritmos na prática em softwares profissionais, caso necessário.
Baseado nestas considerações, verificamos que o efeito desse estudo trouxe resultados positivos e profundos, já que norteou o conceito de ordenação (como implementá-lo, em quais casos e a grande quantidade e diferença desses algoritmos), contribuindo em diversas disciplinas, tais quais a matemática (que foi necessária para entender a complexidade dos algoritmos), a lógica (dado que cada algoritmo possui uma lógica por trás de sua implementação e execução), e a programação (já que são algoritmos).